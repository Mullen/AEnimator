{   //MODIFIED BY JOE PALASEK    /*  1. Image files cannot have spaces in their names. Please use "_" instead.  2. Objects on the timeline should ONLY be PNGs, JPEGS, or Solids. Do not use text, videos, PSDs, or nested compositions.  3. Images should be cropped as tightly as possible.  4. Images should be run through ImageOptim to reduce file size.  5. Images in compositions, at their largest size, should be 100%. Meaning, don't bring an image into AE that is 3000px by 3000px, and then scale it down to 33% to use it as a 1000px by 1000px. Instead, resize in Photoshop, export, and reload footage.  6. Do not use masks, effects, or filters.  7. Do not script or loop any animations.    8. Do not use any 3D transforms. Stick to these properties: "Anchor Point" "Position" "Scale" "Rotation" and "Opacity".  10. Only use one marker at the begining of each layer (if need be). It can be used for passing variables.  11. All layers should have a keyframe of some sort.  12. All images should be linked from their correct project folders.  13. Image names should never contain spaces.  14. Do not use easing.  15. 1 comp per file.  17. Minimize keyframes and layers as much as possible.  */    /*  TODO:  		- Composition Markers to indicate secondary content.  		- Textfields as option?  */  #include "../lib/Logger.jsx";  #include "../lib/json2.js"  #include "../lib/utilities.js"  var L = new Logger();    function AEnimator(thisObj) {    L.indentOn(false);    this.FRAME_TO_PIXEL_MULTIPLIER = 1;        this.absProjectPath = app.project.file.parent.absoluteURI;        //Error check and store Project name    this.proj = app.project;    this.projectName = app.project.file.name.replace(".aep", '');    if(this.projectName.hasWhiteSpace()){	    alert("Export Failed: Please remove all whitespace from the project's filename.");	    return;    }    if(this.projectName.isFirstCharANumber()){	    alert("Export Failed: Please make sure the project's filename starts with a letter.");	    return;    }            //Error check and store Current Comp name    this.comp = app.project.activeItem;    if(this.comp instanceof CompItem == false){	    alert("Export Failed: Please set your mouse focus on the Composition or Timeline Panel and try again.");	    return;    }    this.compName = this.comp.name;    if(this.compName.hasWhiteSpace()){	    alert("Export Failed: Please remove all whitespace from composition name: " + this.compName);	    return;    }    if(this.compName.isFirstCharANumber()){	    alert("Export Failed: Please make sure the following composition's name starts with a letter: " + this.compName);	    return;    }        //Voltron Project and Comp name    this.projCompName = this.projectName + "-" + this.compName;        this.originalTimeDisplayType = this.proj.timeDisplayType;        this.proj.timeDisplayType = TimeDisplayType.FRAMES;        this.compFrameRate = this.comp.frameRate;    this.compDuration = this.comp.duration;    this.compTotalFrames = Math.round(this.compFrameRate * this.compDuration); 	  this.compDurationMultiplied = this.FRAME_TO_PIXEL_MULTIPLIER * this.compTotalFrames;        this.layersArray = this.getLayers();    this.layersArray.reverse();        this.generateChapterPovAnimationData();		this.generateCSS();		//this.generateHTML();        this.proj.timeDisplayType = this.originalTimeDisplayType;        alert("Export Successful!");  };    AEnimator.prototype.getLayers = function() {    var _layerArray = [];        if(this.comp instanceof CompItem) {            for(i = 1; i < this.comp.layers.length + 1; i++) {        _layerArray.push( new LayerObj(this.comp.layers[i], this.compName, this.compDuration, this.compTotalFrames, this.FRAME_TO_PIXEL_MULTIPLIER) );      }    }        return _layerArray;  };    AEnimator.prototype.generateChapterPovAnimationData = function() {  	  	var _file = new File(this.absProjectPath + "/" + this.projCompName + ".json"),  			_exportObj = {  				$id: "#" + this.projCompName,	  			compDurationMultiplied: this.compDurationMultiplied,	  			layerDataArrayLength: this.layersArray.length,	  			layerDataArray: this.getLayerDataExportArrayObj()  			};  	    _file.open("w", undefined, undefined);    _file.encoding = "UTF-8";    _file.lineFeed = "Unix";        _file.write(JSON.stringify(_exportObj, null, "\t"));    _file.close();      };    AEnimator.prototype.getLayerDataExportArrayObj = function(){  	var _layerData = [];  		  for(var i = 0; i < this.layersArray.length; i++){		  var _layer = this.layersArray[i];		  _layerData.push({			  $id: "#"+_layer.id,			  iV: _layer.inPointScrollPos == 0,			  //index: _layer.index,			  iI: !_layer.isSolid,			  oHQ: _layer.isOnlyHQ,			  fHQ: _layer.isForceHQ,			  //nativeWidth: _layer.nativeWidth,			  //nativeHeight: _layer.nativeHeight,			  //inPointPercentage: _layer.inPointPercentage,			  //inPointFrameNumber: _layer.inPointFrameNumber,			  iS: _layer.inPointScrollPos,			  //outPointPercentage: _layer.outPointPercentage,			  //outPointFrameNumber: _layer.outPointFrameNumber,			  oS: _layer.outPointScrollPos,			  //usedAnimPropertyNames: _layer.usedAnimPropertyNames,			  pPR: _layer.passiveParallaxRange,			  f0S: _layer.frame0Styles,			  kL: _layer.keyframesArrayLength,			  k: _layer.keyframesArray		  });	  }	  	  return _layerData;  };    AEnimator.prototype.generateCSS = function() {  	var _file = new File(this.absProjectPath + "/" + this.projCompName + ".css");    _file.open("w", undefined, undefined);    _file.encoding = "UTF-8";    _file.lineFeed = "Unix";            for(var i = 0; i < this.layersArray.length; i++){    	var _layer = this.layersArray[i];	    _file.writeln("." + this.projCompName + " > ." + _layer.id +"{");	    _file.writeln("\twidth: " + _layer.nativeWidth + "px;");	    _file.writeln("\theight: " + _layer.nativeHeight + "px;");	    if(_layer.isSolid){		    _file.writeln("\tbackground: " + _layer.hexColor + ";");	    }					//Frame 0 styles			_file.writeln("\topacity: " + _layer.frame0Styles.o + ";");	  		  var _translate2DString = "translate(" + _layer.frame0Styles.t.x + "px, " + _layer.frame0Styles.t.y + "px)",		  		_translate3DString = "translate3d(" + _layer.frame0Styles.t.x + "px, " + _layer.frame0Styles.t.y + "px, 0px)",		  		_scaleString = "scale(" + _layer.frame0Styles.s.x + ", " + _layer.frame0Styles.s.y + ")",		  		_rotateString = "rotate(" + _layer.frame0Styles.r + "deg)",		  		_transformString2D = _translate2DString + _scaleString + _rotateString,		  		_transformString3D = _translate3DString + _scaleString + _rotateString,		  		_transformOriginString = _layer.frame0Styles.tO.x + "px " + _layer.frame0Styles.tO.y + "px";		  _file.writeln("");			_file.writeln("\ttransform-origin: " + _transformOriginString + ";");		  _file.writeln("\t-webkit-transform-origin: " + _transformOriginString + ";");			_file.writeln("\t-moz-transform-origin: " + _transformOriginString + ";");			_file.writeln("\t-o-transform-origin: " + _transformOriginString + ";");			_file.writeln("\t-ms-transform-origin: " + _transformOriginString + ";");			_file.writeln("");		  _file.writeln("\ttransform: " + _transformString2D + ";");		  _file.writeln("\t-webkit-transform: " + _transformString2D + ";");			_file.writeln("\t-moz-transform: " + _transformString2D + ";");			_file.writeln("\t-o-transform: " + _transformString2D + ";");			_file.writeln("\t-ms-transform: " + _transformString2D + ";");		  _file.writeln("");		  _file.writeln("\ttransform: " + _transformString3D + ";");		  _file.writeln("\t-webkit-transform: " + _transformString3D + ";");			_file.writeln("\t-moz-transform: " + _transformString3D + ";");			_file.writeln("\t-o-transform: " + _transformString3D + ";");			_file.writeln("\t-ms-transform: " + _transformString3D + ";");				    _file.writeln("}");    }        _file.close();  };    AEnimator.prototype.generateHTML = function() {  	var _file = new File(this.absProjectPath + "/" + this.projCompName + ".markup.html");    _file.open("w", undefined, undefined);    _file.encoding = "UTF-8";    _file.lineFeed = "Unix";        _file.writeln("<section id='"+ this.projCompName + "' class='" + this.projCompName + " parallaxSection'>");        for(var i = 0; i < this.layersArray.length; i++){    	var _layer = this.layersArray[i],    			_visibleClassString = _layer.inPointScrollPos == 0 ? " visible" : " hidden";    	    	    	if(_layer.isSolid){    		_file.writeln("\t<div id='" + _layer.id + "' class='" + _layer.id + " parallaxElement" + _visibleClassString + "'></div>");    	} else {    	    		var _nullImgSrc = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",    				_imgPathString = "<%= asset_path('" + "parallax/" + this.compName + "/" + _layer.imgName + "') %>",    				_lastIndexOfPeriod = _layer.imgName.lastIndexOf('.'),    				_imgPathPrefix = _layer.imgName.substr(0, _lastIndexOfPeriod),    				_imgPathSuffix = _layer.imgName.substr(_lastIndexOfPeriod, _layer.imgName.length - _lastIndexOfPeriod),    				_imgPathStringSM = "<%= asset_path('" + "parallax/" + this.compName + "/" + (_imgPathPrefix + "_halfSized" + _imgPathSuffix)+ "') %>";    			    	_file.writeln("\t<img id='" + _layer.id + "' class='" + _layer.id + " parallaxElement" + _visibleClassString + "' src='"+ _nullImgSrc + "' data-src='" + _imgPathString + "'  data-srcsm='" + _imgPathStringSM + "' alt='" + _layer.id + "'>");    	}    }    _file.writeln("</section>");            _file.close();  };                      function LayerObj(Layer, CompName, CompDuration, CompTotalFrames, FRAME_TO_PIXEL_MULTIPLIER){	  this.layer = Layer;	  	  this.compName = CompName;	  this.compDuration = CompDuration;	  this.compTotalFrames = CompTotalFrames;	  	  this.VALID_ANIM_PROPERTIES = ["Anchor Point", "Position", "Scale", "Rotation", "Opacity"];	  this.FRAME_TO_PIXEL_MULTIPLIER = FRAME_TO_PIXEL_MULTIPLIER;	  	  this.layerName = this.layer.name;	  if(this.layerName.hasWhiteSpace()){	    alert("Export Failed: Please remove all whitespace from layer name: " + this.layerName);	    return;    }    if(this.layerName.isFirstCharANumber()){	    alert("Export Failed: Please make sure the following layer name starts with a letter: " + this.layerName);	    return;    }        this.isSolid = this.layer.source.mainSource instanceof SolidSource ? true : false;	  	  if(this.isSolid){	  	this.hexColor = this.rgbToHex(String(this.layer.source.mainSource.color).split(","));  	} else {	  	this.footageFilename = String(this.layer.source.mainSource.file.name);	  	this.footageFilePathRelative = String(this.layer.source.mainSource.file.relativeURI);			alert(this.footageFilePathRelative);			//alert(decodeURI(this.footageFilename).hasWhiteSpace());  	}	  	  this.index = this.layer.index;	  this.id = this.layerName + "_" + this.index;	  this.nativeWidth = this.layer.source.width;	  this.nativeHeight = this.layer.source.height;	    	  	if(this.layer.property("Marker").numKeys > 1){	  	alert(this.id + " has more than one layer marker. fix this please!");  	}    	// Passive Parallax props  	this.passiveParallaxRange = this.getPassiveParralaxRangeArray(this.layer);  	this.isOnlyHQ = this.getIsOnlyHQ(this.layer);  	this.isForceHQ = this.getIsForceHQ(this.layer);  	  	// InPoint / OutPoint  	this.inPointPercentage = this.layer.inPoint / this.compDuration;	  this.inPointFrameNumber = this.inPointPercentage * this.compTotalFrames;	  this.outPointPercentage = this.layer.outPoint / this.compDuration;	  this.outPointFrameNumber = this.outPointPercentage * this.compTotalFrames;	  	  this.inPointScrollPos = this.FRAME_TO_PIXEL_MULTIPLIER * this.inPointFrameNumber;	  this.outPointScrollPos = this.FRAME_TO_PIXEL_MULTIPLIER * this.outPointFrameNumber;	  	  // Keyframes	  this.usedAnimPropertyNames = [];	  	  this.frame0Styles = this.getFrame0Styles();	  this.frame0Styles.t.x = Number((this.frame0Styles.t.x - this.frame0Styles.tO.x).toFixed(5));	  this.frame0Styles.t.y = Number((this.frame0Styles.t.y - this.frame0Styles.tO.y).toFixed(5));	  	  this.keyframesArray = this.getKeyframes();	  this.mergeKeyframesWithSameTimelinePosition();	  this.keyframesArray.sort(function(a,b) { return parseFloat(a.compPosFrameNumber) - parseFloat(b.compPosFrameNumber) } );	  this.propagateAnimPropertiesToAllKeyframes();	  this.correctTranslatesAndTransformOrigins();	  this.removeKeyframePropertiesNotNeededForExport();	  this.keyframesArrayLength = this.keyframesArray.length;  };    LayerObj.prototype.rgbToHex = function(_rgbArray) {		return "#" + this.componentToHex(Math.round(_rgbArray[0] * 255)) + this.componentToHex(Math.round(_rgbArray[1] * 255)) + this.componentToHex(Math.round(_rgbArray[2] * 255));	};    LayerObj.prototype.componentToHex = function(c) {		var hex = c.toString(16);		return hex.length == 1 ? "0" + hex : hex;	};    LayerObj.prototype.getPassiveParralaxRangeArray = function(Layer){	  if(Layer.property("Marker").numKeys > 0 && Layer.property("Marker").keyValue(1).getParameters().passiveParallaxRange){		  var _pp = (Layer.property("Marker").keyValue(1).getParameters().passiveParallaxRange).split(",");		  		  switch(_pp.length){			  case 1:			  	return {				  	x: Number(_pp[0]),				  	y: Number(_pp[0])				  };			  	break;			  case 2:			  	return {			  	x: Number(_pp[0]),			  	y: Number(_pp[1])			  };			  	break;			  				  default:			  	return null;			  	break;		  }	  } else {		  return null;	  }  };    LayerObj.prototype.getIsOnlyHQ = function(Layer){  		  return (Layer.property("Marker").numKeys > 0 && String(Layer.property("Marker").keyValue(1).getParameters().onlyHQ) == "1") ? 1 : 0;  };    LayerObj.prototype.getIsForceHQ = function(Layer){  		  return (Layer.property("Marker").numKeys > 0 && String(Layer.property("Marker").keyValue(1).getParameters().forceHQ) == "1") ? 1 : 0;  };      LayerObj.prototype.getKeyframes = function(){	  var _keyframesArray = [],	  		_animPropertyArray = this.layer["transform"],	  		_numOfAnimProperties = _animPropertyArray.numProperties;	  	  //CYCLE THROUGH PROPERTIES AND THEIR KEYFRAMES, AND CREATE NEW KEYFRAMES FOR ALL!	  for(var i = 1; i < _numOfAnimProperties + 1; i++){	  	var _animProperty = _animPropertyArray.property(i),	  			_animPropertyName = _animProperty.name;	  		  		  	if(this.isAnimPropertyValid(_animPropertyName) && _animProperty.numKeys > 0){		  	this.addAnimPropertyNameToUsedProperties(_animPropertyName);		  			  	for(var j = 1; j < _animProperty.numKeys + 1; j++){		  		var _keyTime = _animProperty.keyTime(j);		  				  		_keyframesArray.push({		  			compPosTime: _keyTime,			  		compPosPercentage: _keyTime / this.compDuration,			  		compPosFrameNumber: (_keyTime / this.compDuration) * this.compTotalFrames,			  		sP: this.FRAME_TO_PIXEL_MULTIPLIER * ((_keyTime / this.compDuration) * this.compTotalFrames),			  		s: this.keyframeStyleForAnimPropertNameAtTime(_animPropertyName, _keyTime)		  		});		  	}	  	}	  }	  	  return _keyframesArray;  };    LayerObj.prototype.keyframeStyleForAnimPropertNameAtTime = function(AnimPropertyName, KeyTime){	  var _keyValue = this.layer["transform"][AnimPropertyName].valueAtTime(KeyTime, false),	  		_cssName = this.animPropertyNameToCSSPropertyName(AnimPropertyName),	  		_styleObj = {};	  			  	  switch(AnimPropertyName){			case "Anchor Point":				_styleObj[_cssName] = {					x: Number(_keyValue[0].toFixed(5)),					y: Number(_keyValue[1].toFixed(5))				};				break;			case "Position":				_styleObj[_cssName] = {					x: _keyValue[0],					y: _keyValue[1]				};				break;			case "Scale":				_styleObj[_cssName] = {					x: Number((_keyValue[0]/100).toFixed(5)),					y: Number((_keyValue[1]/100).toFixed(5))				};				break;			case "Rotation":				_styleObj[_cssName] = Number(_keyValue.toFixed(5));				break;			case "Opacity":				_styleObj[_cssName] = Number((_keyValue/100).toFixed(5));				break;		}				return _styleObj;  };    LayerObj.prototype.animPropertyNameToCSSPropertyName = function(AnimPropertyName){	  switch(AnimPropertyName){			case "Anchor Point":				return "tO";			case "Position":				return "t";			case "Scale":				return "s";			case "Rotation":				return "r";			case "Opacity":				return "o";		}  };    LayerObj.prototype.cssPropertyNameToAnimPropertyName = function(CSSPropertyName){	  switch(CSSPropertyName){			case "tO":				return "Anchor Point";			case "t":				return "Position";			case "s":				return "Scale";			case "r":				return "Rotation";			case "o":				return "Opacity";		}  };    			LayerObj.prototype.mergeKeyframesWithSameTimelinePosition = function(){		for(var i = 0; i < this.keyframesArray.length; i++){			var _primKeyframe = this.keyframesArray[i];						for(var j = 0; j < this.keyframesArray.length; j++){				var _secKeyframe = this.keyframesArray[j];				if((_secKeyframe != _primKeyframe) && (_secKeyframe.compPosFrameNumber == _primKeyframe.compPosFrameNumber)){					//MERGE!					for(key in _secKeyframe.s){						_primKeyframe.s[key] = _secKeyframe.s[key];					}					this.keyframesArray.splice(j, 1);					j -= 1;				}			}		}	};		LayerObj.prototype.propagateAnimPropertiesToAllKeyframes = function(){		for(var i = 0; i < this.keyframesArray.length; i++){			var _keyframe = this.keyframesArray[i];						for(var j = 0; j < this.usedAnimPropertyNames.length; j++){				var _animPropName = this.usedAnimPropertyNames[j],						_cssAnimProp = this.animPropertyNameToCSSPropertyName(_animPropName);				if(!_keyframe.s[_cssAnimProp]){						var _KVProp = this.keyframeStyleForAnimPropertNameAtTime(_animPropName, _keyframe.compPosTime);					 						for(key in _KVProp){							_keyframe.s[key] = _KVProp[key];						}				}			}		}	};		LayerObj.prototype.correctTranslatesAndTransformOrigins = function(){		for(var i = 0; i < this.keyframesArray.length; i++){			var _keyframe = this.keyframesArray[i];						if(_keyframe.s.t){				if(_keyframe.s.tO){					_keyframe.s.t.x = Number((_keyframe.s.t.x - _keyframe.s.tO.x).toFixed(5));					_keyframe.s.t.y = Number((_keyframe.s.t.y - _keyframe.s.tO.y).toFixed(5));				} else {					_keyframe.s.t.x =  Number((_keyframe.s.t.x - this.frame0Styles.tO.x).toFixed(5));					_keyframe.s.t.y =  Number((_keyframe.s.t.y - this.frame0Styles.tO.y).toFixed(5));				}			}		}	};		LayerObj.prototype.removeKeyframePropertiesNotNeededForExport = function(){		for(var i = 0; i < this.keyframesArray.length; i++){			var _keyframe = this.keyframesArray[i];						delete _keyframe.compPosTime;			delete _keyframe.compPosPercentage;			delete _keyframe.compPosFrameNumber;		}	};    LayerObj.prototype.getFrame0Styles = function(){  	var _styles = {};  	  	for(var i = 0; i < this.VALID_ANIM_PROPERTIES.length; i++){			var _keyStyleObj = this.keyframeStyleForAnimPropertNameAtTime(this.VALID_ANIM_PROPERTIES[i], 0);						for(key in _keyStyleObj){				_styles[key] = _keyStyleObj[key];			}   	}  	return _styles;  };    LayerObj.prototype.isAnimPropertyKeyed = function(AnimPropertyName){  	for(var i = 0; i < this.usedAnimPropertyNames.length; i++){	  	if(AnimPropertyName == this.usedAnimPropertyNames[i]){		  	return true;	  	}  	}  	return false;  };    LayerObj.prototype.isAnimPropertyValid = function(AnimPropertyName){  	for(var i = 0; i < this.VALID_ANIM_PROPERTIES.length; i++){	  	if(AnimPropertyName == this.VALID_ANIM_PROPERTIES[i]){		  	return true;	  	}  	}  	return false;  };    LayerObj.prototype.addAnimPropertyNameToUsedProperties = function(AnimPropertyName){	  for(var i = 0; i < this.usedAnimPropertyNames.length; i++){		  if(AnimPropertyName == this.usedAnimPropertyNames[i]){			  return;		  }	  }	  this.usedAnimPropertyNames.push(AnimPropertyName);  };        var l2wg = new AEnimator(this);  delete l2wg;}